{
  "id": "how-rag-works",
  "slug": "how-rag-works",
  "title": "A Practical Way to Think About RAG",
  "date": "2025-12-12T10:00:00.000Z",
  "cover": "/assets/images/blog/how-rag-works-cover.png",
  "excerpt": "A grounded mental model for Retrieval-Augmented Generation, with two concrete examples and the tradeoffs that actually matter.",
  "html": "<p>Retrieval-Augmented Generation (RAG) shows up constantly in conversations about LLM applications, especially once private or fast-changing data enters the picture. What I kept noticing was a gap between two kinds of explanations. Some stayed so abstract that it was hard to tell when RAG actually helped. Others jumped straight into tools and pipelines without first explaining what problem the system was really solving.</p>\n<p>This is the mental model I keep coming back to when evaluating RAG systems. It is not exhaustive, but it is enough to make informed design decisions and to recognize when RAG is likely to help and when it is likely to cause problems.</p>\n<h2>Why RAG exists</h2>\n<p>Language models are strong at reasoning over text, but they operate inside a fixed knowledge boundary. They do not know your internal documents, policies, or product details unless those are explicitly provided at inference time. They also do not update themselves as your information changes.</p>\n<p>When a question depends on knowledge outside the model’s training data, the model has no mechanism to retrieve it on its own. Without help, it fills in gaps using general patterns, which is often where hallucinations start.</p>\n<p>RAG exists to address this limitation. It gives the model access to relevant external information at the moment it generates an answer, without retraining or fine-tuning the model itself.</p>\n<p>That distinction matters. RAG does not make the model smarter. It makes the system more grounded.</p>\n<h2>A useful way to think about it</h2>\n<p>The simplest way to think about RAG is as a separation of responsibilities.</p>\n<p>The model is responsible for reasoning, synthesis, and language. The system around it is responsible for deciding what information the model should see.</p>\n<p>If you ask a question that depends on internal context, the quality of the answer depends almost entirely on whether the right reference material was placed in front of the model first. RAG is the mechanism that performs that selection.</p>\n<p>Once you frame it this way, most debates about RAG become debates about retrieval quality rather than model behavior. It explains why systems can feel unreliable even when the model is doing its job.</p>\n<h2>The basic flow, with emphasis on what matters</h2>\n<p>Most RAG systems follow the same general pattern, but not all parts are equally important.</p>\n<p>Documents are first split into chunks. These should be large enough to preserve meaning but small enough to be retrieved selectively. Chunking is one of the most underestimated parts of RAG, and it is where many systems quietly go wrong.</p>\n<p>In practice, chunk boundaries often need to respect document structure, such as sections or paragraphs, rather than arbitrary token counts. Some overlap between chunks is also common, not to improve recall in theory, but to avoid cutting important context in half.</p>\n<p>Each chunk is then converted into an embedding that represents its semantic meaning. When a user asks a question, the question is embedded as well, and the system retrieves the chunks that appear closest in meaning.</p>\n<p>Embedding quality matters, but it rarely compensates for poor chunking or unclear queries. Most retrieval failures show up well before vector similarity becomes the limiting factor.</p>\n<p>Those retrieved chunks are added to the prompt along with the user’s question. The model then generates a response based on that supplied context.</p>\n<p>The loop itself is simple. The difficulty comes from making each step reliable under real data.</p>\n<h2>A concrete example that usually works</h2>\n<p>Imagine an internal policy document that covers refunds, eligibility criteria, timelines, and edge cases. A user asks, “Can customers get a refund after 30 days?”</p>\n<p>With RAG, the retrieval step might surface three chunks: one defining eligibility, one describing standard timelines, and one listing exceptions. The model answers using those specific sections instead of relying on general knowledge about refunds.</p>\n<p>If the answer is correct, it is because retrieval surfaced the right material. If it is wrong, the problem is almost always that an important chunk was missed or that irrelevant context crowded out the relevant one.</p>\n<p>This pattern repeats across use cases.</p>\n<h2>A second example, where RAG often fails</h2>\n<p>A common failure case shows up in troubleshooting or operational knowledge bases.</p>\n<p>Suppose you have a long document describing how to debug a production issue, including prerequisites, conditional steps, and warnings. A user asks a targeted question like, “Why does service X fail only after a config reload?”</p>\n<p>Retrieval may return chunks that mention service X and config reloads, but miss a critical section explaining an ordering constraint or a hidden dependency. The model produces an answer that sounds reasonable, cites the retrieved context, and is still wrong in a way that is hard to detect.</p>\n<p>This kind of failure is subtle. The system appears to work. The answer is coherent. But an important constraint was never retrieved, so the model could not reason about it.</p>\n<p>This is one of the reasons RAG systems can feel unreliable in operational settings. They fail quietly when retrieval misses the one piece that actually matters.</p>\n<h2>What RAG does well, and what it does not</h2>\n<p>RAG works best when the task involves synthesizing information from a body of text that already contains the answer. It is well suited for policy questions, documentation lookup, and knowledge-based summarization.</p>\n<p>It is much less effective when correctness depends on precise values, strict ordering, or full coverage of edge cases. In those situations, missing context is not a minor issue. It invalidates the answer.</p>\n<p>This is also why prompt tuning rarely fixes weak RAG systems. If retrieval is off, prompting only rearranges the same incomplete inputs.</p>\n<h2>When RAG is the wrong choice</h2>\n<p>RAG is often treated as a default architecture, but in many cases it introduces more complexity than it removes.</p>\n<p>If your dataset is small and stable, fine-tuning or even simple in-prompt examples may be more reliable. If the task requires deterministic outputs, structured extraction, or exact correctness, a rules-based or programmatic approach is usually safer.</p>\n<p>RAG shines when the problem is about informed synthesis, not enforcement or computation.</p>\n<h2>A simple way to visualize the system</h2>\n<p>Here is the basic flow. Most complexity in real systems is layered on top of this, not a replacement for it.</p>\n<img src=\"/assets/images/blog/rag-user-question-flow.svg\" alt=\"drawing\" width=\"200\" style=\"display: block; margin: auto;\"/>\n\n<h3>What each step does:</h3>\n<p><strong>User question</strong></p>\n<p>Someone asks something like &quot;Can customers get a refund after 30 days?&quot; This triggers the RAG pipeline. The system needs to find relevant information to answer this specific question.</p>\n<p><strong>Embed the question</strong></p>\n<p>The question gets converted into a vector embedding that captures its semantic meaning. This is not about matching keywords. It is about what the question actually means. &quot;Refund policy for late requests&quot; and &quot;Can I get my money back after a month?&quot; would produce similar embeddings even though the words are different.</p>\n<p><strong>Retrieve relevant chunks</strong></p>\n<p>The system compares the question&#39;s embedding against all the chunks in your document store and finds the ones that are semantically closest. These are the chunks most likely to contain relevant information. This usually returns somewhere between 3 and 10 chunks.</p>\n<p><strong>Add chunks to the prompt</strong></p>\n<p>The retrieved chunks get inserted into the prompt along with the original question. Instead of just asking &quot;Can customers get a refund after 30 days?&quot;, the system is now asking &quot;Given these policy sections: [chunk 1, chunk 2, chunk 3], can customers get a refund after 30 days?&quot;</p>\n<p><strong>Generate a response</strong></p>\n<p>The model reads the question and the context chunks, then generates an answer. It does the same reasoning it always does, but now it has the specific information it needs. The quality of this answer depends almost entirely on whether retrieval found the right chunks.</p>\n<h2>Closing</h2>\n<p>Keeping this flow in mind helps keep systems understandable, even as more advanced techniques are layered on top.</p>\n<p>RAG is best understood as a pattern, not a product or a feature. It is a way to control what information a language model sees at the moment it produces an answer.</p>\n<p>Many modern systems layer additional techniques on top of this pattern, such as hybrid retrieval, reranking, or multi-step queries. These can improve results, but they do not change the underlying shape of the system. Retrieval still determines what the model can reason about. Generation determines how that reasoning is expressed.</p>\n<p>As a starting point, this mental model is enough to decide whether RAG belongs in a system and where the real risks are. Once that’s clear, deeper implementation choices become easier to make and easier to question.</p>\n",
  "url": "https://nick.karnik.io/blog/how-rag-works",
  "tags": [
    "LLM",
    "RAG",
    "Architecture"
  ]
}